<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>MZ-LiveNav</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-rotate@0.1.0/dist/leaflet-rotate.js"></script>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #map {
            height: calc(100% - 100px);
        }

        #controls {
            padding: 10px;
            background: #f4f4f4;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid #ccc;
            z-index: 1000;
        }

        button {
            padding: 6px 10px;
            background: #0078ff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #status {
            font-size: 14px;
            margin-left: 10px;
        }

        #turnArrow {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            border: 1px solid #ccc;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            z-index: 1000;
            text-align: center;
        }

        #turnArrow span {
            font-size: 14px;
        }

        #orientationInfo {
            position: absolute;
            top: 100px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-size: 12px;
            z-index: 1000;
        }

        .ego-vehicle {
            background-color: blue;
            border-radius: 50%;
            width: 14px;
            height: 14px;
            position: relative;
        }

        .ego-vehicle::after {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 8px solid blue;
        }

        .compass-rose {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            border: 2px solid #333;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .leaflet-control-rotate {
            background: white;
            border-radius: 4px;
            padding: 5px;
        }
        .leaflet-control-rotate {
          visibility: hidden;
        }
    </style>
</head>

<body>
    <div id="controls">
        <button id="btnClear"; style="background-color:rgb(221, 74, 74)">Clear</button>
        <button id="btnCreateRoute"; style="background-color:rgb(54, 116, 54)">Create Route</button>
        <!-- <button id="btnToggleView">View: Ego-Centric</button> -->
        <button id="btnFollowMode">Follow: OFF</button>
        <span id="status">Waiting for GNSS...</span>
    </div>

    <div id="map"></div>
    <div id="turnArrow"><span style="font-size: 96;">👆</span></div>
    <div id="orientationInfo">Yaw: --°</div>
    <div id="compassRose" class="compass-rose">N</div>

    <div id="footer" style="padding: 20px; font-size: small; font-weight: 800;">Copyright © 2025 Minus Zero Robotics Pvt. Ltd.</div>

    <script>
        const map = L.map('map', {
            rotate: true,
            bearing: 0
        }).setView([20.5937, 78.9629], 5);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OSM contributors'
        }).addTo(map);

        // L.control.rotate().addTo(map);

        let routeId = null,
            routePoly = [],
            routeLine = null;
        let gnssMarker = null,
            activeRoute = false,
            followMode = false,
            plotProj = false;
        let latestGNSS = { lat: null, lon: null, yaw: 0 };
        let waypointMarkers = [],
            turnMarkers = [],
            destinationMarker = null;
        let isEgoCentricView = true;

        const statusEl = document.getElementById('status'),
            turnArrowEl = document.getElementById('turnArrow'),
            orientationInfoEl = document.getElementById('orientationInfo'),
            // toggleViewBtn = document.getElementById('btnToggleView'),
            compassRoseEl = document.getElementById('compassRose'),
            followModeBtn = document.getElementById('btnFollowMode');

        function normalizeAngle(degrees) {
            return (degrees % 360 + 360) % 360;
        }

        function adjustYawForMap(yawDegrees) {
            return -(yawDegrees + 360) % 360;
        }

        async function fetchLatestGNSS() {
            try {
                const res = await fetch('/latest_position');
                if (!res.ok) return;
                const data = await res.json();
                latestGNSS = { 
                    lat: data.lat, 
                    lon: data.lon, 
                    yaw: data.yaw || 0 
                };
                // console.log('Raw Yaw:', data.yaw, 'Adjusted:', adjustYawForMap(data.yaw));
                updateGNSSMarker(data.lat, data.lon);
                updateOrientationInfo();
                if (activeRoute) await updateTurnByTurn();
            } catch (e) {
                console.warn('GNSS fetch error', e);
            }
        }
        setInterval(fetchLatestGNSS, 50);

        function updateOrientationInfo() {
            const yawDegrees = adjustYawForMap(latestGNSS.yaw);
            orientationInfoEl.textContent = `Yaw: ${yawDegrees.toFixed(1)}°`;
            
            updateCompassRose(yawDegrees);
        }

        function updateCompassRose(bearing) {
            const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            const index = Math.round(bearing / 45) % 8;
            compassRoseEl.textContent = directions[index];
            compassRoseEl.style.transform = `rotate(${-bearing}deg)`;
        }

        function updateGNSSMarker(lat, lon) {
            if (!gnssMarker) {
                gnssMarker = L.marker([lat, lon], {
                    icon: L.divIcon({
                        className: 'ego-vehicle-marker',
                        html: '<div class="ego-vehicle"></div>',
                        iconSize: [14, 14],
                        iconAnchor: [7, 7]
                    })
                }).addTo(map).bindPopup('Current Position');
                
                if (isEgoCentricView) {
                    setEgoCentricView();
                } else {
                    map.setView([lat, lon], 18);
                }
            } else {
                gnssMarker.setLatLng([lat, lon]);
                
                if (followMode) {
                    if (isEgoCentricView) {
                        setEgoCentricView();
                    } else {
                        map.panTo([lat, lon]);
                    }
                }
            }
        }

        let lastYaw = 0;
        function smoothYaw(newYaw, alpha = 0.2) {
            lastYaw = lastYaw + alpha * ((newYaw - lastYaw + 540) % 360 - 180);
            return (lastYaw + 360) % 360;
        }

        function setEgoCentricView() {
            if (!latestGNSS.lat) return;
            map.setView([latestGNSS.lat, latestGNSS.lon], 18);
            const bearing = smoothYaw(adjustYawForMap(latestGNSS.yaw));
            map.setBearing(bearing);
        }

        // toggleViewBtn.onclick = () => {
        //     isEgoCentricView = !isEgoCentricView;
        //     toggleViewBtn.textContent = isEgoCentricView ? 'View: Normal' : 'View: Ego-Centric';
            
        //     if (isEgoCentricView && latestGNSS.lat) {
        //         setEgoCentricView();
        //     } else {
        //         map.setBearing(0);
        //         if (latestGNSS.lat) {
        //             map.setView([latestGNSS.lat, latestGNSS.lon], 15);
        //         }
        //     }
        // };

        followModeBtn.onclick = () => {
            followMode = !followMode;
            followModeBtn.textContent = `Follow: ${followMode ? 'ON' : 'OFF'}`;
            if (followMode && latestGNSS.lat && gnssMarker) {
                if (isEgoCentricView) {
                    setEgoCentricView();
                } else {
                    map.panTo([latestGNSS.lat, latestGNSS.lon]);
                }
            }
        };

        function testYawAdjustment() {
            const testValues = [0, 90, 180, 270];
            console.log('Testing yaw adjustments:');
            testValues.forEach(yaw => {
                console.log(`Raw: ${yaw}° -> Adjusted: ${adjustYawForMap(yaw)}°`);
            });
        }

        testYawAdjustment();

        map.on('click', e => {
            const currentBearing = map.getBearing();
            
            if (currentBearing !== 0) {
                map.setBearing(0);
            }
            
            const { lat, lng } = e.latlng;
            const marker = L.marker([lat, lng], {
                icon: L.icon({
                    iconUrl: 'https://cdn-icons-png.flaticon.com/512/684/684908.png',
                    iconSize: [25, 25],
                    iconAnchor: [12, 12] // Center of the icon
                })
            }).addTo(map).bindPopup(`Waypoint ${waypointMarkers.length + 1}`).openPopup();
            waypointMarkers.push(marker);
            statusEl.textContent = `Added waypoint #${waypointMarkers.length}`;
            
            setTimeout(() => {
                if (isEgoCentricView && latestGNSS.lat) {
                    setEgoCentricView();
                } else if (currentBearing !== 0) {
                    map.setBearing(currentBearing);
                }
            }, 100);
        });

        document.getElementById('btnCreateRoute').onclick = async () => {
            if (!latestGNSS.lat) {
                alert("Waiting for GNSS fix...");
                return;
            }
            if (waypointMarkers.length === 0) {
                alert("Click on map to add at least one waypoint.");
                return;
            }

            const currentBearing = map.getBearing();
            const currentZoom = map.getZoom();

            if (currentBearing !== 0) {
                map.setBearing(0);
            }

            const origin = [latestGNSS.lon, latestGNSS.lat];
            const destinations = waypointMarkers.map(m => [m.getLatLng().lng, m.getLatLng().lat]);
            const waypoints = [origin, ...destinations];

            statusEl.textContent = 'Requesting route...';
            const res = await fetch('/route', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ waypoints })
            });
            if (!res.ok) {
                statusEl.textContent = 'Route fetch error';
                // Restore bearing on error
                if (currentBearing !== 0) {
                    map.setBearing(currentBearing);
                }
                return;
            }
            const data = await res.json();
            routeId = data.route_id;
            routePoly = data.geometry.map(([lon, lat]) => [lat, lon]);

            if (routeLine) map.removeLayer(routeLine);
            routeLine = L.polyline(routePoly, { color: 'blue', weight: 4 }).addTo(map);
            
            waypointMarkers.slice(0, -1).forEach(m => map.removeLayer(m));
            const lastWaypoint = waypointMarkers[waypointMarkers.length - 1];
            waypointMarkers = [lastWaypoint];

            if (destinationMarker) map.removeLayer(destinationMarker);
            const [destLat, destLon] = [lastWaypoint.getLatLng().lat, lastWaypoint.getLatLng().lng];
            destinationMarker = L.marker([destLat, destLon], {
                icon: L.icon({
                    iconUrl: 'https://cdn-icons-png.flaticon.com/512/684/684908.png',
                    iconSize: [30, 30],
                    iconAnchor: [15, 15] // Center of the icon
                })
            }).addTo(map).bindPopup("Destination").openPopup();

            turnMarkers.forEach(m => map.removeLayer(m));
            turnMarkers = [];
            data.maneuvers.forEach((man, idx) => {
                const [lat, lon] = [man.location[1], man.location[0]];
                const arrow = (man.modifier || "").toLowerCase().includes('left') ? '👈' :
                    (man.modifier || "").toLowerCase().includes('right') ? '👉' :
                        (man.modifier || "").toLowerCase().includes('uturn') ? '↩️' : '👆';
                const marker = L.marker([lat, lon], {
                    icon: L.divIcon({ 
                        html: `<span style="font-size:20px">${arrow}</span>`, 
                        className: '', 
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    })
                }).addTo(map).bindPopup(`Turn ${idx + 1}: ${man.instruction}`);
                turnMarkers.push(marker);
            });

            statusEl.textContent = `Route ready (${(data.distance_m / 1000).toFixed(2)} km) with ${data.maneuvers.length} turns`;
            activeRoute = true;

            if (isEgoCentricView && latestGNSS.lat) {
                setEgoCentricView();
            } else {
                if (!isEgoCentricView) {
                    map.fitBounds(routeLine.getBounds());
                }
                if (currentBearing !== 0) {
                    setTimeout(() => {
                        map.setBearing(currentBearing);
                        map.setZoom(currentZoom);
                    }, 100);
                }
            }

            // await fetch('/set_route_id', {
            //     method: 'POST',
            //     headers: { 'Content-Type': 'application/json' },
            //     body: JSON.stringify({ route_id: routeId })
            // });
        };

        async function updateTurnByTurn() {
            if (!routeId || !latestGNSS.lat) return;
            const res = await fetch('/position', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ route_id: routeId, position: [latestGNSS.lon, latestGNSS.lat] })
            });
            if (!res.ok) return;
            const data = await res.json();

            projected_pos = data.projected_point
            // console.log(projected_pos)
            
            if (plotProj) {
            projMarker = L.marker([projected_pos[1], projected_pos[0]], {
                    icon: L.icon({
                    iconUrl: 'https://cdn-icons-png.flaticon.com/512/684/684908.png',
                    iconSize: [12, 12],
                    iconAnchor: [6, 6]
                    })
                }).addTo(map).bindPopup('proj');
            }

            if (data.rerouted && data.new_route_id) {
                routeId = data.new_route_id;

                if (routeLine) map.removeLayer(routeLine);
                turnMarkers.forEach(m => map.removeLayer(m));
                turnMarkers = [];

                routeLine = L.polyline(data.geometry.map(p => [p[1], p[0]]), { color: 'blue', weight: 4 }).addTo(map);
                
                if (!isEgoCentricView) {
                    map.fitBounds(routeLine.getBounds());
                }

                data.maneuvers.forEach((man, idx) => {
                    const [lon, lat] = man.location;
                    const arrow = (man.modifier || "").toLowerCase().includes('left') ? '👈' :
                        (man.modifier || "").toLowerCase().includes('right') ? '👉' :
                            (man.modifier || "").toLowerCase().includes('uturn') ? '↩️' : '👆';
                    const marker = L.marker([lat, lon], {
                        icon: L.divIcon({ 
                            html: `<span style="font-size:20px">${arrow}</span>`, 
                            className: '', 
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        })
                    }).addTo(map).bindPopup(`Turn ${idx + 1}: ${man.instruction}`);
                    turnMarkers.push(marker);
                });

                statusEl.textContent = `Rerouted! Next maneuver updated.`;
            }

            if (data.next_maneuver) {
                const man = data.next_maneuver;
                const dist = man.distance_to_maneuver_m || 0;
                const mod = (man.modifier || "").toLowerCase();
                const arrow = mod.includes('left') ? '👈' : mod.includes('right') ? '👉' : mod.includes('uturn') ? '↩️' : '👆';
                turnArrowEl.innerHTML = `<span style="font-size:48px">${arrow}</span><span>${dist.toFixed(0)} m</span>`;
                statusEl.textContent = `Next: ${mod || 'straight'} in ${dist.toFixed(0)} m`;
            } else {
                turnArrowEl.innerHTML = '👆';
                statusEl.textContent = 'Approaching destination...';
            }
        }

        document.getElementById('btnClear').onclick = async () => {
            map.setBearing(0);
            
            try {
                await fetch('/clear_route', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ route_id: routeId })
                });
                console.log('Cleared route successfully')
            } catch (err) {
                console.warn('clear_route request failed', err);
            }

            if (routeLine) map.removeLayer(routeLine);
            waypointMarkers.forEach(m => map.removeLayer(m));
            turnMarkers.forEach(m => map.removeLayer(m));
            if (destinationMarker) map.removeLayer(destinationMarker);

            waypointMarkers = [];
            turnMarkers = [];
            routeLine = null;
            routeId = null;
            destinationMarker = null;
            activeRoute = false;

            statusEl.textContent = 'Cleared route.';
            turnArrowEl.innerHTML = '👆';

            if (isEgoCentricView && latestGNSS.lat) {
                setTimeout(() => {
                    setEgoCentricView();
                }, 100);
            }
        };

        function debugMarkerPosition(marker, name) {
            if (!marker) return;
            const latlng = marker.getLatLng();
            console.log(`${name} Marker - Lat: ${latlng.lat}, Lng: ${latlng.lng}`);
            console.log(`Map Bearing: ${map.getBearing()}°`);
            
            L.circle(latlng, {
                color: 'red',
                fillColor: '#f03',
                fillOpacity: 0.5,
                radius: 2
            }).addTo(map).bindPopup(`${name} Exact Position`).openPopup();
        }
    </script>
</body>

</html>